
pro desat_pril::identify_saturation_regions_pril, info, strpril, loud, extend_sat_region, max_level_sat=max_level_sat, check_sat
  ;+
  ; NAME:
  ; identify_saturation_regions_pril
  ; PURPOSE:
  ; Identification of saturation area and diffraction fringes pixels generated by the identified saturation area.
  ; EXPLANATION:
  ; We select two regions of the image (I_1 with intensities > 15000 and the
  ; I_2 with intensities < 10000) and we first define the saturation area as
  ; the region I_1. Then, considering the support of the convolution product
  ; between mask_s, defined as mask_s(s) = 1. and 0 elsewhere (where s are
  ; the indexes of saturated pixels), and the psf diffraction component is
  ; possible to find out the diffraction fringes directly generated by the
  ; saturation site.
  ; Finally, if extended_sat_region is equal to 1
  ; we extend the saturation area by adding some neighboring
  ; pixels around it (pixels obtained by convolving the mask
  ; mask_z(I_2) = 0 and 1 elsewhere with the diffusion component).
  ; (Remark: the extension of the saturation area improves the edge effects in
  ; the reconstruction but it is recommended only when the saturation area is already
  ; a widespread region. Therefore, this keyword is automatically set in the current
  ; function: if the number of saturated pixels is greater than the optional input called
  ; max_level_sat (default max_level_sat=2000), then the keyword extend_sat_region
  ; is set equal to 1). The keyword check_sat is set equal to 1. If data is not saturated
  ; 'check_sat' is set equal to 0 in the current function (and the desaturation procedure stops
  ; for this image).
  ; ; CALLING SEQUENCE:
  ; identify_saturation_regions_pril, info, strpril, loud, extend_sat_region, max_level_sat=max_level_sat
  ; INPUTS:
  ; strpril     = dst_strpril global structure for the desaturation routine.
  ; extend_sat_region = 1 if a larger saturation region is considered 0 otherwise
  ; OPTIONAL:
  ; max_level_sat = number of pixels which determines if a saturation region has to
  ;                 be considered as a large region in order to set the keyword
  ;                 extend_sat_region if it is not already set equal to 1
  ; OUTPUT:
  ; strpril.s   = saturated pixels position
  ; strpril.z   = flaring pixels (not saturated pixels, with high intensity avoided by the method)
  ; strpril.g   = diffraction fringes pixels position (generated by the all saturation region, i.e strpril.s)
  ; strpril.ns  = number of saturated pixel with intensity over 15000
  ; CALLS:
  ;   CONVOLVE
  ; CALLED BY:
  ;   DESATURATION
  ;-

  ;cpsf = the diffraction psf component
  cpsf = (*self.psf).cpsf
  ;opsf = the diffusion psf component
  opsf = ((*self.psf).opsf)[*,*,0]

  ;im = saturated image.
  im    = *strpril.im
  bkg   = *strpril.bg

  im = double(im)
  cpsf = double(cpsf)

  if max(im) gt 15000 then begin

    Q_2 = im lt 10000 ;
    Q_1 = im gt 15000 ;
    I_1 = where( Q_1 ) ; indexes
    I_2 = where( Q_2 )

    ; Saturated pixels defined as pixels in I_1
    s = I_1
    ; Mask of saturated pixels
    mask_s = im * 0. & mask_s[s] = 1.


    default, max_level_sat, 2000
    ; If the keyword extend_sat_region is not set then it is automatically
    ; set in the following way:
    ; if the number of saturated pixels is greater than the max_level_set
    ; then it is set to 1
    ; otherwise it is set to 0
    if ~keyword_set(extend_sat_region) then begin
      if n_elements(s) gt max_level_sat then begin
        extend_sat_region = 1
      endif else begin
        extend_sat_region = 0
      endelse
    endif

    if size(cpsf, /n_d) eq 3 then begin
      corr_fring = im * 0
      for iw = 0, (size(cpsf, /dim))[2] - 1 do corr_fring += convolve( mask_s, cpsf[*,*,iw] )
      corr_fring = corr_fring ge (1.e-3 * max(cpsf))
    endif else begin
      corr_fring = convolve( mask_s, cpsf ) ge (1.e-3 * max(cpsf))
    endelse

    corr_g = where(corr_fring and Q_2)
    mask_fringes = im * 0.
    mask_fringes[corr_g] = 1.


    in  = {s      : ptr_new(I_1)        ,$
      g      : ptr_new(corr_g)      ,$
      im    : ptr_new(im)       ,$
      bg    : ptr_new(bkg)        ,$
      x   : ptr_new(/allocate_heap) ,$
      y   : ptr_new(/allocate_heap) ,$
      c_exp   : ptr_new(/allocate_heap) ,$
      ns    : total(Q_1)        ,$
      npix  : strpril.npix          ,$
      c_stat  : 0             }



    if size(cpsf,/n_d) eq 3 then begin
      message, 'Not Enabled'
    endif


    if size(cpsf, /n_d) eq 3 then begin
      tmp = im * 0
      for iw = 0, (size(cpsf, /dim))[2] - 1 do tmp += convolve( mask_s, cpsf[*,*,iw] )
      qfwd_ind = tmp ge (1.e-3 * max(cpsf))
    endif else begin
      qfwd_ind = convolve( mask_s, cpsf ) ge 1.e-3 * max(cpsf)
    endelse
    fwd_ind = where( qfwd_ind )

    mask_z = im * 0 + 1 & mask_z[ I_2 ] = 0.
    q_z = convolve(mask_z, opsf) gt min(opsf[where(opsf gt 0)])
    z= where(q_z)

    ;;; DATA (Fringe) PIXELS
    g = where(Q_2 and qfwd_ind and ~q_z)
    mg = byte( im * 0 ) & mg[z] = 1b & gg = where( Q_2 and Qfwd_ind and ~mg )
    if ~same_data2( gg, g) then stop
    mask_g = im * 0. & mask_g[g] = 1.

    ; If keyword extend_sat_region is equal to 1 then we extend the saturation region
    if extend_sat_region then begin
      s = where(q_z or Q_1 )
      mask_s = im * 0. & mask_s[s] = 1.
    endif

    if loud then begin

      index2map, info ,mask_s , map
      plot_map, map, /positive, /square ,title = 'Mask of saturation region', thick=1.5

    endif

    strpril.s = ptr_new(s) ; SATURATED PIXELS (BLOOMED + PRIMARY SATURATED PIXELS)
    strpril.z = ptr_new(z) ; FLARING PIXELS
    strpril.g = ptr_new(g) ; FRINGES PIXELS
    strpril.ns = total(Q_1) ; NUMBER OF PIXELS WITH INTENSITY OVER 15000

  endif else begin
    check_sat = 0
  endelse

end



pro desat_pril::dst_sparse_mtrx , strpril , cpsf, opsf, model
  ;+
  ; NAME:
  ; dst_sparse_mtrx
  ; PURPOSE:
  ; It computes the circulant matrix associated to the diffraction component of the psf
  ; in a sparse way and re-weight it according to the PRiL method strategy. Furthermore,
  ; if the keyword model is equal to 1 the matrix is built so that it takes into account the
  ; information into the saturation region using the diffusion component of the psf.
  ; EXPLANATION:
  ; select the components of the convolution matrix that links the saturated pixels strpril.s
  ; with the diffraction fringes in strpril.g and save the necessary vectors to construct the
  ; sparse matrix. The matrix is re-weighted according to the PRiL method strategy: each column
  ; is multiplyed by 1./sqrt(im[strpril.g]+1.). If the keyword model is equal to 1, it computes the sum
  ; of values along the image columns in the saturation region and select the components of
  ; the convolution matrix that links the saturated pixels strpril.s with the ones
  ; which are involved in the integration flux along each image column and save the necessary
  ; vectors to construct the sparse matrix and again the matrix is re-weighted according to
  ; the PRiL method strategy
  ; CALLING SEQUENCE:
  ; dst_mtrx , strpril , cpsf, opsf, model
  ; INPUTS:
  ; strpril   = dst_strpril global structure for the desaturation routine.
  ; cpsf  = diffraction component of the PSF
  ; opsf  = diffusion component of the PSF
  ; model = 1 if the energy constraint along the image columns is requested
  ; OUTPUT:
  ; strpril.mtrx = sparse_mtrx is a structure which contains the necessary vectors to construct the
  ;            matrix in a sparse way
  ; strpril.y    = vector containing the diffraction fringes intensities. If the keyword model is equal to 1
  ;            it contains also the data of the flux integrated along the image columns in the
  ;            saturation region
  ; CALLS:
  ;   matlab_get_val, matlab_index, matlab_array_indices
  ; CALLED BY:
  ;   DESATURATION
  ;
  ;-
  s     = *strpril.s ; saturated indexes
  g     = *strpril.g ; fringes indexes
  y     = double(*strpril.im) > 0 ; image as it is

  dim   = size(/dim , *strpril.im)
  n_g   = size(/n_e , g) ; number of fringes pixels
  n_s   = size(/n_e , s) ; number of saturated pixels

  ; Mask of saturated pixels
  mask_s = y*0.
  mask_s[s] = 1.
  ; 2d wrapping of the saturated indexes
  ij_sat = array_indices(*strpril.im , s)

  ; check: if some saturated pixels are both on the bottom and top edges of the image and the keyword
  ; model is setted as 1 we write a warning and we set the keyword model equal to 0
  ; (in this case the saturation effects can extend over the field of view of the image and
  ; the constraint of the energy along the image columns could lead into an wrong information)
  if min(ij_sat[1,*]) eq 0 && max(ij_sat[1,*]) eq dim[1]-1 then begin
    if model eq 1 then begin
      print, 'WARNING: you can not use the flux constraint along image columns since the saturation effects could extend over the field of view of the image. The computation will continue without the flux constraint. '
      model = 0
    endif
  endif

  ; Column indexes of saturated pixels
  ind_columns = ij_sat[0,*]
  ; Row indexes of saturated pixels
  ind_rows = ij_sat[1,*]

  sortx = ind_columns(sort(ind_columns))
  ; Ordered and without repetition column indexes of saturated pixels
  ind_sat_columns = sortx(uniq(sortx))
  ; Number of saturated columns in the image
  n_c = n_elements(ind_sat_columns)
  ; Image in the saturation area
  im_masked_s = y*mask_s

  y_c = total(im_masked_s,2)
  ; Flux in saturated image integrated along the image columns in correspondence of the saturation region
  y_c = y_c[ind_sat_columns]


  ; Initialization of vectors xx, yy and zz as empty vectors
  xx = [] ; in xx we save indexes of fringes pixels linked to the i-th saturated pixel (and indexes of columns of saturated region if model is equal to 1)
  yy = [] ; in yy we save indexes of saturated pixels
  zz = [] ; in zz we save values of the cpsf, rescaled according to the PRiL strategy, on fringes pixels in xx (and values of the integration along
  ; the image columns in the saturation region, rescaled according to the PRiL strategy, on column indexes in xx if model is equal to 1)


  ; cpsf = diffraction component of psf
  cpsf = double(cpsf)
  ; opsf = diffusion component of psf
  opsf = double(opsf)
  c0 = cpsf & c0(where(cpsf le 1e-2 * max(cpsf))) = 0 ; c0 is the psf low cut

  ; Conversion of indexes to construct vectors xx, yy and zz.
  ; Vectors xx, yy and zz define the sparse matrix to
  ; give as input in the glmnet algorithm which calls an exe file
  ; Conversion of saturated indexes s according to the MATLAB lexicographic order
  t = matlab_index(*strpril.im, s)
  ; Conversion of fringes pixels indexes g according to the MATLAB lexicographic order
  g_m = matlab_index(*strpril.im, g)

  ; Conversion of saturated pixels t (ordered according to the MATLAB lexicographic order)
  ; to 2-dimensional subscripts according to the MATLAB lexicographic order
  ij_sat_convert = matlab_array_indices(*strpril.im, t)
  i_sat_convert = ij_sat_convert[0,*] ; row indexes
  j_sat_convert = ij_sat_convert[1,*] ; column indexes
  ; Fringes pixels values ordered according to the MATLAB indexes g_m
  y_g_convert = matlab_get_val(*strpril.im, g_m)

  ; IDL indexes corresponding to the MATLAB indexes ij_sat_convert
  i_sat_idl = dim[0]-i_sat_convert ; row indexes
  j_sat_idl = j_sat_convert - 1 ; column indexes
  ij_sat_idl = [j_sat_idl, i_sat_idl]

  for i = 0, n_s-1 do begin ; given the center of a psf
    ;;; shift the psf cut and intesect with the fringes
    c1 = (shift(c0 , ij_sat_idl[0,i] - dim[0]/2 , ij_sat_idl[1,i] - dim[1]/2 ))

    c1_g = matlab_get_val(c1, g_m)

    c2 = c1_g / sqrt(y_g_convert + 1.);;; rescaled values according to the PRiL strategy

    ;;; store values greater than zero
    aa = WHERE(c2 gt 0.) ; indexes of fringes pixels linked to the i-th saturated pixel
    bb = replicate(i,n_elements(aa)) ; index of i-th saturated pixel (bb as the same size of aa)
    cc = c2[aa] ; values on fringes pixels saved in vector aa of the cpsf rescaled according to the PRiL strategy

    if model then begin
      ;;; shift the opsf and intesect with the saturation area
      c3 = (shift(opsf , ij_sat_idl[0,i] - dim[0]/2 , ij_sat_idl[1,i] - dim[1]/2 ))
      c3 = total(c3*mask_s,2)
      c3 = c3[ind_sat_columns] ; Sum of values in c3 along saturated image columns
      c4 = c3 / sqrt(y_c + 1.);;; rescaled values according to the PRiL strategy
      aa2 = WHERE(c4 gt 0) ; indexes of columns related to the i-th saturated pixel
      cc2 = c4[aa2] ; values on column indexes saved in aa2 of the integration along columns in the saturation region
      ; rescaled according to the PRiL strategy

      aa = [aa, aa2 + n_g] ; union of indexes aa and aa2 + n_g
      bb = [bb, replicate(i,n_elements(aa2))]  ;index of i-th saturated pixel (bb as the same size of aa)
      cc = [cc, cc2] ; union of values in cc and in cc2
    endif

    ;; collect data together
    ; update of vectors xx, yy and zz
    xx = [ xx, aa ]
    yy = [ yy, bb ]
    zz = [ zz, cc ]


  endfor

  ; create pcs vector useful to construct the sparse matrix in the exe file
  tmp = make_array(n_s,/LONG)
  for i=0,n_s-1 do tmp[i]=total(yy eq i)
  pcs = [0 , total(tmp, /cumulative, /preserve_type)] + 1


  ; Matlab compatibility indexes
  xx = xx + 1
  yy = yy + 1

  ; Create structure sparse_mtrx which contains
  ; - row indexes irs defined by xx
  ; - column indexes jcs defined by yy
  ; - values on [irs,jcs] xs defined by zz
  ; - pcs vector to construct the sparse matrix defined by pcs
  sparse_mtrx = { irs : xx ,$
    jcs : yy ,$
    xs : zz ,$
    pcs : pcs $
  }

  ; Define data of the inverse problem
  if model then begin
    ; if keyword model is equal to 1 the data is the union of the image values on fringes pixels and the integrated
    ; values along columns in the saturation area
    y_data = [y[g], y_c]
  endif else begin
    ; data is the image values on fringes pixels
    y_data = y[g]
  endelse

  strpril.mtrx = ptr_new(sparse_mtrx)
  strpril.y = ptr_new(y_data)

end







pro desat_pril::identify_fringes_pixels, info, strpril, primary_sat, g_fringes_new
  ;+
  ; NAME:
  ; desat_pril::identify_fringes_pixels
  ; PURPOSE:
  ; Identification of diffraction fringes pixels directly generated by the estimated primary saturation site.
  ; EXPLANATION:
  ; Considering the support of the convolution product between the mask of the estimated primary
  ; saturation region and the psf diffraction component is possible to find out the diffraction fringes
  ; pixels directly generated by the estimated primary saturation site.
  ; CALLING SEQUENCE:
  ; identify_fringes_pixels, info, strpril, primary_sat
  ; INPUTS:
  ; strpril           = dst_strpril global structure for the desaturation routine.
  ; primary_sat   = primary saturation region indexes
  ; OUTPUT:
  ; g_fringes_new = diffraction fringes indexes
  ; CALLS:
  ;   CONVOLVE
  ; CALLED BY:
  ;   dst_pril_EM_glmnet
  ;-

  ; diffraction component of psf
  cpsf = (*self.psf).cpsf
  ; diffusion component of psf
  opsf = ((*self.psf).opsf)[*,*,0]

  im    = double(*strpril.im)

  cpsf = double(cpsf)


  Q_2 = im lt 10000
  I_2 = where( Q_2 )

  ; mask of primary saturation region
  mask_pr = im * 0. & mask_pr[primary_sat] = 1



  if size(cpsf, /n_d) eq 3 then begin
    tmp = im * 0
    for iw = 0, (size(cpsf, /dim))[2] - 1 do tmp += convolve( mask_pr, cpsf[*,*,iw] )
    qfwd_ind = tmp ge (1.e-3 * max(cpsf))
  endif else begin
    qfwd_ind = convolve( mask_pr, cpsf ) ge 1.e-3 * max(cpsf)
  endelse
  fwd_ind = where( qfwd_ind )

  mask_z = im * 0 + 1 & mask_z[ I_2 ] = 0.
  q_z = convolve(mask_z, opsf) gt min(opsf[where(opsf gt 0)])
  z= where(q_z)

  ; Diffraction fringes pixels
  g = where(Q_2 and qfwd_ind and ~q_z)
  mg = byte( im * 0 ) & mg[z] = 1b & gg = where( Q_2 and Qfwd_ind and ~mg )
  if ~same_data2( gg, g) then stop
  ; mask of diffraction fringes pixels
  mask_g = im * 0. & mask_g[g] = 1.

  g_fringes_new = g


end

pro desat_pril::glmnet
  ;+
  ; NAME:
  ; desat_pril::glmnet
  ; PURPOSE:
  ; Run an exe file according to the system arch
  ; EXPLANATION:
  ; Run -fortran_glmnet_windows if the system is window
  ;     -fortran_glmnet_linux if the system is linux
  ;     -fortran_glmnet_darwin if the system is mac
  ; CALLING SEQUENCE:
  ; glmnet
  ; CALLS:
  ;   SPAWN
  ; CALLED BY:
  ;   dst_glmnet
  ;-
  glmnet_path = chklog('$SSW/packages/desat/fortran/build/')
  if !VERSION.OS eq "Win32" then SPAWN, glmnet_path + 'fortran_glmnet_windows'  
  if !VERSION.OS eq "linux" then begin & 
     SPAWN, glmnet_path + 'fortran_glmnet_linux'
  endif 
  if !VERSION.OS eq "darwin" then SPAWN, glmnet_path + 'fortran_glmnet_darwin'
end


pro desat_pril::dst_glmnet, strpril, y_data, fit, model, adaptive, weights=weights
  ;+
  ; NAME:
  ; dst_glmnet
  ; PURPOSE:
  ; Compute the path of solutions of PRiL method by solving an l_1-type minimization problem.
  ; EXPLANATION:
  ; Compute the PRiL solutions by solving an l_1-type minimization problem along a grid of lambdas.
  ; It calls an exe file (according to the system arch) to compute the path
  ; of solutions. It returns a structure fit which
  ; contains the grid of regularization parameters on which the minimization is solved (fit.lambda), the solutions
  ; (fit.beta), the estimated intercepts (fit.intercepts), the number of non-zero values of solutions (fit.df),
  ; the R-square values for each solution (fit.dev), the actual number of passes over the data for all lambda values
  ; (fit.npasses) and an error flag, for warnings and errors (fit.jerr).
  ; A re-ordering of indexes is requested for the computation of solutions by means of the exe file.
  ; CALLING SEQUENCE:
  ; dst_glmnet, strpril , y_data , fit, model, adaptive, weights=weights
  ; INPUTS:
  ; strpril   = dst_strpril global structure for the desaturation routine.
  ; y_data  =  data
  ; OPTIONAL:
  ; model = 1 if the energy constraint along the image columns is requested
  ; adaptive = 1 if we insert weights in the l_1 penalty (aadptive strategy)
  ; weights = weights to insert in the l_1 penalty if the adaptive strategy is considered, they are all equal to 1 otherwise
  ; 
  ; OUTPUT:
  ; fit  = structure with the following arguments
  ; fit.beta      = path of solutions  (each column is the solution computed fixing a regularization parameter in the
  ;                 list fit.lambda)
  ; fit.lambda    = grid of regularization parameters (decreasing ordered)
  ; fit.intercept = estimated intercepts (each intercept is computed fixing a regularization parameter in the
  ;                 list fit.lambda)
  ; fit.df        = number of non zero coefficients of each solution in fit.beta
  ; fit.dev       = R-square values for each solution in fit.beta
  ; fit.npasses   = actual number of passes over the data for all lambda values
  ; fit.jerr      = error flag, for warnings and errors
  ;
  ; CALLS:
  ;   matlab_set_val, matlab_index,  matlab_reordering, glmnet
  ; CALLED BY:
  ;   dst_pril_EM_glmnet
  ;-
  ; Saturated image
  im = *strpril.im
  ; Matrix is saved in *strpril.mtrx
  sparse_mtrx = *strpril.mtrx
  ; Saturated pixels
  s = *strpril.s
  ; Fringes pixels
  g = *strpril.g
  ; Number of fringes pixels
  n_g = n_elements(g)
  ; Conversion of fringes pixels g according to the MATLAB lexicographic order
  g_m = matlab_index(im, g)

  ; Data on fringes pixels
  y_g = y_data[0:n_g-1]
  ; Reordering of y_g according to the MATLAB lexicographic order
  y_g_m = matlab_reordering(im, g, y_g)
  if model then begin
    ; if keyword model is equal to 1 the data y is the union of y_g_m and y_c
    ; Flux in saturated image integrated along the image columns in correspondence of the saturation region is saved in y_c
    y_c = y_data[n_g:n_elements(y_data)-1]
    y = [y_g_m, y_c]
  endif else begin
    y = y_g_m
  endelse
  y = DOUBLE(y)
  ; Number of inputs (number of saturated pixels)
  ni = n_elements(s)
  ; Number of outputs (number of elements of data y)
  no = n_elements(y)

  ; cl defines the interval constraints on coefficient values (default [0, +infty])
  cl = make_array(ni,2,/DOUBLE)
  cl(*,0) = 0.0 ; lower bound for coefficients  (default 0.0)
  cl(*,1) = 9.9e35 ; upper bound for coefficients (default 9.9e35)
  
  
  ; weights to insert in the adaptive PRiL version (to use PRiL set them equal to 1)
  if adaptive then begin
    vp = weights 
  endif else begin
    ; weights to insert in the adaptive PRiL version (to use PRiL set them equal to 1)
    vp = make_array(ni,/DOUBLE) + 1.0
  endelse
  
  ; Folder where variables to give to the exe file are
  ; written as .dat files
  folder_build_local = './build'

  file_mkdir, folder_build_local
  cd, folder_build_local
  
  ;;; Write and save variables to give to the exe file
  ;
  ; INTEGERS VARIABLES (the format is (I16))
  ; nnz = number of elements of sparse_mtrx.xs
  OPENW, lun, 'nnz.dat', /GET_LUN
  PRINTF, lun, n_elements(sparse_mtrx.xs), FORMAT='(I16)'
  FREE_LUN, lun
  ; n0 = number of inputs
  OPENW, lun, 'no.dat', /GET_LUN
  PRINTF, lun, no, FORMAT='(I16)'
  FREE_LUN, lun
  ; ni = number of outputs
  OPENW, lun, 'ni.dat', /GET_LUN
  PRINTF, lun, ni, FORMAT='(I16)'
  FREE_LUN, lun
  ; nlam = maximum number of regularization parameters
  nlam = 100
  OPENW, lun, 'nlam.dat', /GET_LUN
  PRINTF, lun, nlam, FORMAT='(I16)'
  FREE_LUN, lun


  ; VECTORS VARIABLES with interger format (I16) or real format (E16.8)
  ; irs = sparse_mtrx.irs (row indexes of sparse_mtrx)
  OPENW, lun, 'irs.dat', /GET_LUN
  PRINTF, lun, sparse_mtrx.irs, FORMAT='(I16)'
  FREE_LUN, lun
  ; jcs = sparse_mtrx.jcs (column indexes of sparse_mtrx)
  OPENW, lun, 'jcs.dat', /GET_LUN
  PRINTF, lun, sparse_mtrx.jcs, FORMAT='(I16)'
  FREE_LUN, lun
  ; pcs = sparse_mtrx.pcs (vector useful to threat the sparse matrix)
  OPENW, lun, 'pcs.dat', /GET_LUN
  PRINTF, lun, sparse_mtrx.pcs, FORMAT='(I16)'
  FREE_LUN, lun
  ; xs = sparse_mtrx.xs (values of sparse_mtrx in correspondence of indexes [irs,jcs])
  OPENW, lun, 'xs.dat', /GET_LUN
  PRINTF, lun, sparse_mtrx.xs, FORMAT='(E16.8)'
  FREE_LUN, lun
  ; y = data
  OPENW, lun, 'y.dat', /GET_LUN
  PRINTF, lun, y, FORMAT='(E16.8)'
  FREE_LUN, lun
  ; vp = weights to insert in the adaptive PRiL version
  OPENW, lun, 'vp.dat', /GET_LUN
  PRINTF, lun, vp, FORMAT='(E16.8)'
  FREE_LUN, lun
  ; w = observation weights (default vector of the same size of y with elements equal to 1)
  OPENW, lun, 'w.dat', /GET_LUN
  PRINTF, lun, y*0.+1., FORMAT='(E16.8)'
  FREE_LUN, lun
  ; cl = interval constraints on coefficient values of solutions (default [0, +infty])
  OPENW, lun, 'cl.dat', /GET_LUN
  PRINTF, lun, cl, FORMAT='(E16.8)'
  FREE_LUN, lun

  ; We clean the folder before writing outputs files .dat of the exe file
  FILE_DELETE, 'lmu.dat', /ALLOW_NONEXISTENT
  FILE_DELETE, 'ca.dat', /ALLOW_NONEXISTENT
  FILE_DELETE, 'ia.dat', /ALLOW_NONEXISTENT
  FILE_DELETE, 'a0.dat', /ALLOW_NONEXISTENT
  FILE_DELETE, 'nin.dat', /ALLOW_NONEXISTENT
  FILE_DELETE, 'rsq.dat', /ALLOW_NONEXISTENT
  FILE_DELETE, 'alm.dat', /ALLOW_NONEXISTENT
  FILE_DELETE, 'nlp.dat', /ALLOW_NONEXISTENT
  FILE_DELETE, 'jerr.dat', /ALLOW_NONEXISTENT

  ; Call the exe file for computations
  print, 'START: glmnet'
  self->glmnet
  print, 'END: glmnet'


  ; Read files written in the exe file
  ; ca cointains compressed coefficients of solutions along the grid of regularization parameters
  ; ca of size nlam x ni (each row is a solution computed with a fixed regularization parameter)
  ca = make_array(ni,nlam,/DOUBLE)
  OPENR, lun, 'ca.dat', /GET_LUN
  READF, lun, ca
  FREE_LUN, lun
  ca=transpose(ca)
  ca[where(ca lt 1.e-12)] = 0.
  ca[where(~finite(ca))] = 0.

  ; lmu = actual number of regularization parameters on which solutions are computed
  OPENR, lun, 'lmu.dat', /GET_LUN
  READF, lun, lmu
  FREE_LUN, lun

  ; a0 = vectors of estimated intercepts (each intercept is computed fixing a regularization parameter )
  a0 = make_array(nlam,/DOUBLE)
  OPENR, lun, 'a0.dat', /GET_LUN
  READF, lun, a0
  FREE_LUN, lun

  ; ia = pointers to coefficients
  ia = make_array(ni,/LONG)
  OPENR, lun, 'ia.dat', /GET_LUN
  READF, lun, ia
  FREE_LUN, lun

  ; nin = number of coefficients for each solution
  nin = make_array(nlam,/LONG)
  OPENR, lun, 'nin.dat', /GET_LUN
  READF, lun, nin
  FREE_LUN, lun

  ; rsq = R-square values for each solution
  rsq = make_array(nlam,/DOUBLE)
  OPENR, lun, 'rsq.dat', /GET_LUN
  READF, lun, rsq
  FREE_LUN, lun

  ; alm = the actual sequence of lambda values used
  alm = make_array(nlam,/DOUBLE)
  OPENR, lun, 'alm.dat', /GET_LUN
  READF, lun, alm
  FREE_LUN, lun

  ; nlp = actual number of passes over the data for all lambda values
  OPENR, lun, 'nlp.dat', /GET_LUN
  READF, lun, nlp
  FREE_LUN, lun

  ; jerr = error flag, for warnings and errors
  ;      jerr  = 0 => no error
  ;      jerr > 0 => fatal error - no output returned
  ;         jerr < 7777 => memory allocation error
  ;         jerr = 7777 => all used predictors have zero variance
  ;         jerr = 10000 => maxval(vp) <= 0.0
  ;      jerr < 0 => non fatal error - partial output:
  ;         Solutions for larger lamdas (1:(k-1)) returned.
  ;         jerr = -k => convergence for kth regularization parameter not reached
  ;            after maxit (see above) iterations.
  ;         jerr = -10000-k => number of non zero coefficients along path
  ;            exceeds nx (see above) at kth regularization value.
  OPENR, lun, 'jerr.dat', /GET_LUN
  READF, lun, jerr
  FREE_LUN, lun
  
  ; Output folder
  ofolder = './../'
  cd, ofolder

  ; Cut nin over the lmu regularization parameters
  nin = nin[0:lmu-1]
  ; Maximum of nin
  ninmax = max(nin)
  ; Cut ca over the lmu regularization parameters
  ca = ca[0:lmu-1,*]
  ; Cut lam over the lmu regularization parameters
  lam = alm[0:lmu-1]
  ; Cut a0 over the lmu regularization parameters
  a0 = a0[0:lmu-1]
  ; Cut rsq over the lmu regularization parameters
  rsq = rsq[0:lmu-1]
  if ninmax gt 0. then begin
    ca = ca[*, 0:ninmax-1]
    ; Number of non-zero coefficients of solutions
    df = total(abs(ca) gt 0. , 2)
    ja = ia[0:ninmax-1]
    oja = sort(ja)
    ja1 = ja[oja]-1
    beta_strpril = make_array(lmu, ni,/DOUBLE)
    ; Reordering of coefficients of solutions
    beta_strpril[*,ja1] = ca[*,oja]
  endif else begin
    beta_strpril = make_array(lmu, ni,/DOUBLE)
    df = make_array(lmu, /DOUBLE)
  endelse


  beta_ = beta_strpril
  ; Conversion of saturated pixels s according to the MATLAB lexicographic order
  t = matlab_index(im, s)


  ; beta_ matrix of size ni x lmu : each column is a solution at a fixed regularization parameter, the solution is ordered
  ; according to the IDL saturated indexes s
  for i=0, lmu-1 do begin
    beta_[i,*] =  matlab_set_val(im, t, beta_strpril[i,*], s)
  endfor


  ;;; CREATE FIT STRUCTURE
  fit = { beta     : PTR_NEW(beta_),$
    intercept : PTR_NEW(a0), $
    lambda    : PTR_NEW(lam),$
    dev    :PTR_NEW(rsq),$
    df    :PTR_NEW(df),$
    npasses    :PTR_NEW(nlp),$
    jerr    :PTR_NEW(jerr) $
  }
end



pro desat_pril::dst_inpaint, x_input, x_output , strpril, extend_sat_region , x_init_guess, nn=nn
  ;+
  ; NAME:
  ; dst_inpaint
  ; PURPOSE:
  ; Smoothing procedure to evaluate intensities in blooming pixels.
  ; EXPLANATION:
  ; Replace the missing data in x_input (the NaN values in x_input are identified as missing data)
  ; by extra/interpolating the non-missing elements. It uses an iterative process based on DCT
  ; (Discrete Cosine Transform) and IDCT (Inverse Discrete Cosine Transform)
  ; CALLING SEQUENCE:
  ; dst_inpaint, x_input, x_output , strpril, extend_sat_region , x_init_guess, nn=nn
  ; INPUTS:
  ; x_input = image with missing data to estimate (missing data are represented by NaN values)
  ; strpril     = dst_strpril global structure for the desaturation routine.
  ; extend_sat_region = 1 if a larger saturation region is considered 0 otherwise
  ; OPTIONAL:
  ; x_init_guess = initial guess (default x_init_guess is estimated by a nearest neighbor interpolation using the function InitialGuess)
  ; nn = number of iterations for the inpainting routine
  ; OUTPUT:
  ; x_output = output image (intensities in missing data are evaluated with the smoothing procedure)
  ; CALLS:
  ; CALLS:
  ;    dct2d_fft, InitialGuess, logspace
  ; CALLED BY:
  ;   dst_image_synthesis_saturation_region
  ; PROCEDURE:
  ;-


  s = *strpril.s
  z = *strpril.z

  ; x_nan image to inpaint
  ; computations on logarithmic values of the image
  ; the output image is finally composed with the exponentional (to assure positive values)
  x_NaN = alog(x_input)

  default, nn, 100.

  W = finite(x_NaN)
  zeros_ww=where(W eq 0., count_zeros_ww, COMPLEMENT = non_zeros_ww)

  if count_zeros_ww gt 0. then begin
    
    
    ;Initial guess
    if keyword_set(x_init_guess) then begin
      x_output_cut = x_init_guess
      s0 = 3.
    endif else begin
      self->InitialGuess, x_NaN, W, x_output, s, z, extend_sat_region
    endelse

    
    ; Initial condition
    x_NaN[zeros_ww] = 0.

    ; Consider a square box including the saturation region
    dims = SIZE(x_NaN,/DIMENSIONS)
    ind_sat = array_indices(dims,s,/DIMENSIONS)
    min_col_ind_sz_non_zeros = min(ind_sat[0,*])
    max_col_ind_sz_non_zeros = max(ind_sat[0,*])
    min_row_ind_sz_non_zeros = min(ind_sat[1,*])
    max_row_ind_sz_non_zeros = max(ind_sat[1,*])
    mask_ = x_NaN * 0.
    ; check on the saturation indexes
    if min_col_ind_sz_non_zeros eq 0 then begin
      min_col_ind_sz_non_zeros = min_col_ind_sz_non_zeros + 1
    endif
    if max_col_ind_sz_non_zeros eq dims[0]-1 then begin
      max_col_ind_sz_non_zeros = max_col_ind_sz_non_zeros - 1
    endif
    if min_row_ind_sz_non_zeros eq 0 then begin
      min_row_ind_sz_non_zeros = min_row_ind_sz_non_zeros + 1
    endif
    if max_row_ind_sz_non_zeros eq dims[1]-1 then begin
      max_row_ind_sz_non_zeros = max_row_ind_sz_non_zeros - 1
    endif
    length_col = max_col_ind_sz_non_zeros-min_col_ind_sz_non_zeros
    length_row = max_row_ind_sz_non_zeros-min_row_ind_sz_non_zeros
    
    ; If length_col and length_row are smaller than 256, take the smallest box including the saturation region, whose size is a power of 2 (between 128 and 256) 
    if max([length_col,length_row]) gt 128 then begin
      max_length_col_row = max([length_col,length_row,256])
    endif else begin
      max_length_col_row = max([length_col,length_row,128])  
    endelse
    
    kk_col=abs(max_length_col_row-length_col)/2.
    kk_row=abs(max_length_col_row-length_row)/2.
    
    x_NaN_cut = x_NaN[min_col_ind_sz_non_zeros-kk_col:max_col_ind_sz_non_zeros+kk_col-1,min_row_ind_sz_non_zeros-kk_row:max_row_ind_sz_non_zeros+kk_row-1]
    
    W_cut=W[min_col_ind_sz_non_zeros-kk_col:max_col_ind_sz_non_zeros+kk_col-1,min_row_ind_sz_non_zeros-kk_row:max_row_ind_sz_non_zeros+kk_row-1]

    
    x_output_cut=x_output[min_col_ind_sz_non_zeros-kk_col:max_col_ind_sz_non_zeros+kk_col-1,min_row_ind_sz_non_zeros-kk_row:max_row_ind_sz_non_zeros+kk_row-1]
   
    sizx = size(/dim , x_NaN_cut) ; sizx[0] is the column number and sizx[1] is the row number

    d = 2.

    Lambda = make_array(sizx, /DOUBLE) * 0.

    for i = 0, d-1 do begin
      siz0 = make_array(d,/DOUBLE)*0.+1.
      siz0[i] = sizx[i]
      vec = findgen(sizx[i], START=1)
      vv=cos(!pi*(reform(vec,[siz0[0],siz0[1]])-1)/sizx[i])
      aux = make_array(sizx[0],sizx[1],/DOUBLE)
      if i eq 0. then begin
        aux = vv # (make_array(sizx[1],1,/DOUBLE)+1.0)
      endif else begin
        aux = vv ## (make_array(sizx[0],1,/DOUBLE)+1.0)
      endelse

      Lambda = Lambda + aux

    endfor
    Lambda = 2*(d-Lambda)


    ; Smoothness parameters: from high to negligible values
    s0 = 3.
    ss = logspace(s0,-6,nn)


    RF = 2. ;relaxation factor

    m = 2.
   
    Lambda = Lambda^m

    for i = 0, nn-1 do begin &
      Gamma_f = 1. / (1.+ss[i]*Lambda) & ;Lambda_cut
      dct_1 = dct2d_fft(W_cut*(x_NaN_cut-x_output_cut)+x_output_cut) &
      x_output_cut = RF*dct2d_fft(Gamma_f*dct_1, /INVERSE) + (1-RF)*x_output_cut &
    endfor &

  
  x_output[min_col_ind_sz_non_zeros-kk_col:max_col_ind_sz_non_zeros+kk_col-1,min_row_ind_sz_non_zeros-kk_row:max_row_ind_sz_non_zeros+kk_row-1]=x_output_cut

  x_output[non_zeros_ww] = x_NaN[non_zeros_ww]
    

endif else begin
  x_output = x_NaN
  print, ' NO NaN '
endelse


x_output = exp(x_output)



end


pro desat_pril::InitialGuess, x_NaN, W, x_output, s, z, extend_sat_region
  ;+
  ; NAME:
  ; InitialGuess
  ; PURPOSE:
  ; Compute an initial guess for the smoothing procedure dst_inpaint making a nearest neighbor
  ; interpolation.
  ; EXPLANATION:
  ; Compute a rough guess with the nearest neighbor interpolation method. We estimate the missing data
  ; in x_NaN using the nearest neighbor interpolation method applied on some given regions of the image.
  ; If extend_sat_region is equal to 0 we estimate the missing data by replacing them with the nearest
  ; non-missing data in the region made of the union of pixels in s and in z, otherwise with the nearest
  ; non-missing data in a box region which contains the pixels in s.
  ; (Remark: if extend_sat_region is equal to 1 the saturation region s contains pixels in z)
  ; CALLING SEQUENCE:
  ; InitialGuess, x_NaN, W, x_output, s0, s, z, extend_sat_region
  ; INPUTS:
  ; x_NaN = image with missing data to estimate (missing data are represented by NaN values)
  ; W     = binary image which has 0 elements in correspondece of missing data and 1 otherwise
  ; s     = saturated pixels
  ; z     = flaring pixels
  ; extend_sat_region = 1 if a larger saturation region is considered 0 otherwise
  ; OPTIONAL:
  ; OUTPUT:
  ; x_output = output image (intensities in missing data are evaluated with the nearest neighbor interpolation method)
  ; CALLS:
  ; CALLED BY:
  ;   dst_inpaint
  ; CALLS:
  ;   intersect, CONVOLVE
  ; PROCEDURE:
  ;-

  dims = SIZE(W,/DIMENSIONS)
  n_total = N_ELEMENTS(W)
  L = W*0.
  ; pixels of non-missing data
  non_zeros = where(W eq 1.)
  ind_non_zeros = array_indices(dims,non_zeros,/DIMENSIONS)
  dims_non_zeros = SIZE(ind_non_zeros,/DIMENSIONS)

  L[non_zeros] = non_zeros
  ; pixels of missing data
  zeros = where(W eq 0.)

  if extend_sat_region then begin
    ; if extend_sat_region is equal to 1 than we estimate missing data using values in a region defined by a
    ; box which contains the saturation region s
    ind_sat = array_indices(dims,s,/DIMENSIONS)
    min_col_ind_sz_non_zeros = min(ind_sat[0,*])
    max_col_ind_sz_non_zeros = max(ind_sat[0,*])
    min_row_ind_sz_non_zeros = min(ind_sat[1,*])
    max_row_ind_sz_non_zeros = max(ind_sat[1,*])
    mask_ = x_NaN * 0.
    ; check on the saturation indexes
    if min_col_ind_sz_non_zeros eq 0 then begin
      min_col_ind_sz_non_zeros = min_col_ind_sz_non_zeros + 1
    endif
    if max_col_ind_sz_non_zeros eq dims[0]-1 then begin
      max_col_ind_sz_non_zeros = max_col_ind_sz_non_zeros - 1
    endif
    if min_row_ind_sz_non_zeros eq 0 then begin
      min_row_ind_sz_non_zeros = min_row_ind_sz_non_zeros + 1
    endif
    if max_row_ind_sz_non_zeros eq dims[1]-1 then begin
      max_row_ind_sz_non_zeros = max_row_ind_sz_non_zeros - 1
    endif
    mask_[min_col_ind_sz_non_zeros-1:max_col_ind_sz_non_zeros+1,min_row_ind_sz_non_zeros-1:max_row_ind_sz_non_zeros+1] = 1.
    x_NaN_masked = x_NaN * mask_
    region = where(x_NaN_masked gt 0.)
    region_sz_non_zeros = intersect(region, non_zeros)
    ind_sz_non_zeros = array_indices(dims,region_sz_non_zeros,/DIMENSIONS)
  endif else begin
    ; if extend_sat_region is equal to 0 than we estimate missing data using values in the region which is
    ; the union of pixels in s and in z
    s_union_z = [s , z]
    sz = s_union_z[sort(s_union_z)]
    s_union_z_order = sz[uniq(sz)]
    sz_non_zeros = intersect(non_zeros, s_union_z_order)
    ind_sz_non_zeros = array_indices(dims,sz_non_zeros,/DIMENSIONS)
  endelse


  dims_sz_non_zeros = SIZE(ind_sz_non_zeros,/DIMENSIONS)

  for i=0,n_elements(zeros)-1 do begin
    ii = zeros[i]
    ind_i = array_indices(dims,ii,/DIMENSIONS)
    dist_pixels = sqrt((ind_sz_non_zeros[0,*]-ind_i[0])^2+(ind_sz_non_zeros[1,*]-ind_i[1])^2)
    min_dist = min(dist_pixels, location)
    loc_indexes = ind_sz_non_zeros[*,location]
    L[ii] = dims[0]*loc_indexes[1]+loc_indexes[0]
  endfor

  x_output = x_NaN
  x_output[zeros] = x_NaN[L[zeros]]

end







pro desat_pril::dst_glmnet_regpath_bisect, strpril ,fit, saturated_value, opsf, tol = tol, extend_sat_region, nn = nn
  ;+
  ; NAME:
  ; dst_glmnet_regpath_bisect
  ; PURPOSE:
  ; Select the optimal solution of the regularization path fit. The optimal solution is selected so that
  ; the sum of its pixel values approximates the overall signal in the saturated region.
  ; EXPLANATION:
  ; Select the solution in fit.beta such that its projection (into the image space, i.e. after the synthesis
  ; procedure) gives a good approximation in the saturation area. We run the path following the bisection method:
  ; fixed a solution in the path we project it into the image space and we evaluate the sum of its pixel values.
  ; If such a sum is a good approximation of the energy in the saturation area (with respect to a given tolerance
  ; tol) then we stop the procedure, else we follow the bisection direction according to have an overestimation
  ; or an underestimation of the reference energy value. In this way few iterations are enough to return a
  ; good approximate solution.

  ; CALLING SEQUENCE:
  ; dst_glmnet_regpath_bisect, strpril , fit, saturated_value, opsf, tol = tol, extend_sat_region, nn = nn
  ; INPUTS:
  ; strpril  = dst_strpril global structure for the desaturation routine.
  ; fit  = structure provided by dst_glmnet function
  ; saturated_value = reference saturation value, i.e. sum of pixel values in saturated region
  ; opsf = diffusion component of the psf
  ; extend_sat_region = 1 if a larger saturation region is considered 0 otherwise
  ; OPTIONAL:
  ; tol    = tolerance on the convergence criterion to select solution (default tol=1e-3)
  ; nn     = number of iterations for the inpainting routine in dst_glmnet_image_synthesis_saturation_region (default nn=50)
  ; OUTPUT:
  ; strpril.x  = retrieved intensities for saturated pixels (optimal solution in fit.beta)
  ; strpril.bg = intercept

  ; CALLS:
  ;   dst_image_synthesis_saturation_region
  ; CALLED BY:
  ;   dst_pril_EM_glmnet
  ;-
  s   = *strpril.s
  g   = *strpril.g
  y   = *strpril.y

  default, tol, 1.e-3
  default, nn, 50

  n_g = n_elements(g)
  n_s = n_elements(s)

  ; grid of regularization parameters (decreasing ordered)
  lambda = *fit.lambda
  ; path of solutions provided by dst_glmnet function
  beta = *fit.beta
  stop_reg = 0.
  ; number of regularization parameters
  n_lambda = n_elements(lambda)
  ; at first iteration t_max is the last index of regularization parameters
  t_max = n_lambda
  ; at first iteration t_min is the first index of regularization parameters
  t_min = 0.
  ; t is the mean point between t_max and t_min
  t = round((t_max+t_min) / 2.)
  stop_reg = 0.
  ; k_iter counts the number of iterations
  k_iter = 0.

  while stop_reg eq 0. do begin

    beta_tmp = beta[t,*]
    ; Skip the zero solution
    if total(beta_tmp) gt 0. then begin
      ; project beta_tmp into the image space (synthesis step only in the saturation area)
      self->dst_image_synthesis_saturation_region, strpril , beta_tmp, opsf, x_s, extend_sat_region, x_init_guess, nn=nn
      ; sum of pixel values of the projection of beta_tmp  (saved in x_s) in the saturation region
      sum_reconstructed_Image = total(abs(x_s[s]))
      ;x_init_guess = x_s
    endif else begin
      ; if beta_tmp is the null solution we set the sum of its pixel values equal to 0
      sum_reconstructed_Image = 0.
    endelse
    ; bisection method to fix the next regularization parameter (with a check on the estimation of saturation area)
    if sum_reconstructed_Image gt saturated_value then begin
      t_max = t
    endif else begin
      t_min = t
    endelse
    ; If the estimation in saturation area is good (with respect to the fixed tolerance tol) then we stop the procedure
    if abs(sum_reconstructed_Image-saturated_value) / saturated_value lt tol then begin
      stop_reg = 1.
      t_opt = t
      beta_opt = beta_tmp
    endif
    ; Check if the convergence of bisection method is reached
    if (t_max-t_min) lt 2. then begin
      stop_reg = 1.
      t_opt = t
      beta_opt = beta_tmp
    endif
    t = round((t_max+t_min)/2.)
    ; update iterations
    k_iter = k_iter +1
  endwhile

  print, 'Number of total iterations in regpath: k_iter = ', k_iter

  ; path of estimated intercepts on the grid of regularization parameters
  bgstruct = *fit.intercept

  ; t_opt is the index of the optimal solution in the path fit.beta
  ; optimal intercept
  bg_opt = bgstruct[t_opt]


  ; beta_opt is the optimal solution

  strpril.x = ptr_new(beta_opt)
  strpril.bg = ptr_new(bg_opt)


end




pro desat_pril::dst_pril_EM_glmnet, strpril , psf, model, extend_sat_region, tol = tol, nn = nn , max_iter = max_iter, info, loud, adaptive, it_0, intercept_backgr = intercept_backgr, sat_lev=sat_lev, threshold_weights=threshold_weights
  ;+
  ; NAME:
  ; dst_pril_EM_glmnet
  ; PURPOSE:
  ; Compute the solution with EM+PRiL method.
  ; EXPLANATION:
  ; First step: it computes the PRiL solution by solving an l_1-type minimization problem
  ; by calling the function dst_glmnet to compute the path of solutions along a grid of lambdas.
  ; Once the path is computed the optimal lambda and therefore the optimal solution is
  ; selected by calling the function dst_glmnet_regpath_bisect. This step provides a first estimate of
  ; the photon flux and an intercept to use as initializations of the photon flux and the
  ; background in the first iteration of the next iterative process.
  ; Second step: it computes an iterative process which alternates an iteration of the EM algorithm and the
  ; PRiL method. The EM algorithm provides an estimate of the background and the PRiL method
  ; provides an estimate of the photon flux. At each iteration the c-statistic on diffraction fringes
  ; pixels is computed and the algorithm stops when the c-statistic criterion is satisfied.
  ; Remark: if the keyword model is equal to 1 the solution is computed with EM+PRiL method with the
  ; energy constraint along saturated image columns
  ; Remark: if the keyword adaptive is equal to 1 the adaptive PRiL strategy is considered in the minimization 
  ; problem: suitable weights, which are computed in dst_adaptive_weights_mask, are inserted in the l_1 penalty.
  ; 
  ; CALLING SEQUENCE:
  ; dst_pril_EM_glmnet, strpril , psf , model, extend_sat_region, tol = tol, nn = nn , max_iter = max_iter
  ; INPUTS:
  ; strpril   = dst_strpril global structure for the desaturation routine.
  ; psf  =  psf
  ; model = 1 if the energy constrain along the image columns is requested
  ; extend_sat_region = 1 if a larger saturation region is considered 0 otherwise
  ; adaptive = 1 if the adaptive strategy is considered (weights in the l_1 penalty are inserted)
  ; OPTIONAL:
  ; tol   = tolerance value to put in dst_glmnet_regpath_bisect (default tol = 1e-3)
  ; nn    = number of iteration to use in dst_image_synthesis_saturation_region (default nn = 50)
  ; max_iter =  maximum number of iterations in EM+PRiL algorithm (default max_iter=10)
  ; intercept_backgr = threshold on the estimate of the first intercept which defines if the PRiL solution has to be projected (default intercept_backgr = 15.)
  ; sat_lev = saturation level (default sat_level = 15000.)
  ; threshold_weights = constant in the definition of weights if the adaptive strategy is considered (default threshold_weights = 1.02)
  ; 
  ; 
  ; OUTPUT:
  ; strpril.x      = retrieved intensities for saturated pixels
  ; strpril.y      = array corresponding to the diffraction fringes intensities
  ; strpril.c_exp  = expectation computed by the method (mtrx*beta + bg at the last iteration)
  ; strpril.c_stat = c_statistic computed between the image values on diffraction fringes pixels and c_exp
  ; strpril.g      = diffraction fringes pixels generated by the estimated primary saturation region
  ; it_0           = 1 if solution is at the 0-th iteration, 0 otherwise
  ; CALLS:
  ;   dst_glmnet_regpath_bisect, dst_glmnet, idl_Xb, identify_fringes_pixels, dst_adaptive_weights_mask, matlab_reordering
  ; CALLED BY:
  ;   DESATURATION
  ;-
  s   = *strpril.s
  g   = *strpril.g
  y   = *strPRiL.y
  sparse_mtrx = *strpril.mtrx
  bg  = *strpril.bg
  im = *strpril.im

  ; Diffusion component of psf
  opsf = psf.opsf
  ; Diffraction component of psf
  cpsf = psf.cpsf

  n_g = n_elements(g)
  n_s = n_elements(s)

  default , tol , 1.e-3
  default , max_iter , 10
  default, it_0, 0
  default, intercept_backgr, 15.
  default, sat_lev, 15000.
  default, threshold_weights, 1.02

  ; Sum of values in overall saturation region
  saturated_value = total(abs(im[s]))

  ; Reweight defined according to the PRiL strategy
  reweight = 1. / sqrt( y+1.)

  ; Re-weighted data on fringes pixels according to the PRiL strategy
  y_reweight = y * reweight
  
  if adaptive then begin
    self->dst_adaptive_weights_mask, strpril, weights_mask, threshold_weights=threshold_weights
    weights_s = weights_mask[s]
    weights = matlab_reordering(*strpril.im, s, weights_s)
  endif else begin
    weights = make_array(n_s,/DOUBLE) + 1.0
  endelse
  
  
  ; Compute PRiL solutions and estimate intercepts by solving an l_1-type minimization problem
  ; with function dst_glmnet
  self->dst_glmnet, strpril, y_reweight, fit, model, adaptive, weights=weights

  ; Selection of the optimal solution and intercept in the path of solutions provided by the function dst_glmnet
  self->dst_glmnet_regpath_bisect, strpril ,fit, saturated_value, opsf, tol=tol, extend_sat_region, nn=nn

  ; The optimal solution provided by the function dst_glmnet_regpath_bisect is saved in strpril.x and the
  ; estimated intercept is saved in strpril.bg
  beta_bkup = *strpril.x
  bg = *strpril.bg
  bg_backup = bg
  
  if bg_backup gt intercept_backgr then begin
    beta_bkup[where(beta_bkup lt sat_lev)]=0
  endif
  
  beta = transpose(beta_bkup)
  

  ; Set strpril.x equal to beta in order to have the synthesis step to show a first estimate
  ; of the reconstruction
  strpril.x = ptr_new(beta)
  pr_tmp = s[where(beta)]

  ; Identification of diffraction fringes pixels from the estimated primary saturation region
  self->identify_fringes_pixels, info, strpril, pr_tmp, g_fringes_new
  ;
  strpril.g = ptr_new(g_fringes_new)

  ; First estimate of the reconstruction
  self->dst_image_synthesis_inpaint, strpril , psf, extend_sat_region, x_init_guess

  if loud then begin

    index2map, info , (*strpril.x>0.)^0.3 , map
    plot_map, map, /positive, /square ,title = 'First reconstruction', thick=1.5

  endif
  
  rec_it_0 = *strpril.x

  strpril.g = ptr_new(g)
  strpril.x = ptr_new(beta_bkup)

  ; array of the same dimension of data y which replicates the intercept value bg
  bg_array = make_array(n_elements(reweight),value = bg)
  ; Re-weighted background according to the PRiL strategy
  bkg = bg_array / reweight


  stop_reg = 0.

  ; initialization of the array in which we save the estimated flux computed into fringes pixels at each iteration
  flux_pred = make_array(max_iter,/DOUBLE)
  ; initialization of array in which we save the c-statistic computed into fringes pixels at each iteration
  c_stat_iter = make_array(max_iter,/DOUBLE)

  n_iter = 0


  ; Vectors which define the sparse matrix
  xx = sparse_mtrx.irs
  yy = sparse_mtrx.jcs
  zz = sparse_mtrx.xs


  if model then begin
    ij_sat = array_indices(im , s)
    ind_columns = ij_sat[0,*]
    sortx = ind_columns(sort(ind_columns))
    ; Ordered and without repetition indexes of saturated columns
    ind_sat_columns = sortx(uniq(sortx))
    ; Number of saturated columns
    n_c = n_elements(ind_sat_columns)
  endif else begin
    n_c = 0
  endelse



  dim_mtrx = n_g + n_c

  ; Construction of sparse matrix (remark: -1 for idl compatibility)
  mtrx = sprsin( yy-1, xx-1, zz, dim_mtrx )

  ; Compute C-stat for the first reconstruction (iteration 0)

  ; Image values on identified diffraction fringes pixels g_fringes_new
  y_exp_fringes = im[g_fringes_new]
  ; Product mtrx * beta_tmp and reweighting according to PRiL strategy
  Xb_tmp = idl_Xb(im, s, beta, dim_mtrx, mtrx, g, model)  / reweight
  ; Values of mtrx * beta_tmp on fringes pixels g
  Xb_tmp = Xb_tmp[0:n_g-1]

  xb_mask_tmp = im * 0.
  xb_mask_tmp[g] = Xb_tmp

  bkg_cut = bkg[0:n_g-1]
  bkg_mask_tmp = im * 0.
  bkg_mask_tmp[g] = bkg_cut

  ; Predicted values on diffraction fringes pixels g_fringes_new
  y_pred_fringes = xb_mask_tmp[g_fringes_new] + bkg_mask_tmp[g_fringes_new]

  ; Save the sum of predicted values on diffraction fringes g_fringes_new
  flux_pred[n_iter] = total(y_pred_fringes)
  ; Compute c-statistics between y_exp_fringes and y_pred_fringes
  C_stat = c_statistic( y_exp_fringes , y_pred_fringes)
  c_stat_iter[n_iter] = C_stat
  y_pred_fringes_old = y_pred_fringes
  g_fringes = g_fringes_new
  print, ' Iteration number ', n_iter, ': C-stat = ', c_stat, ' Flux pred = ', flux_pred[n_iter], ' Flux exp = ', total(y_exp_fringes)

  ;;;;;
  n_iter = n_iter+1

  WHILE stop_reg eq 0. && n_iter lt max_iter do begin
    ; Xb is the product mtrx * beta
    Xb = idl_Xb(im, s, beta, dim_mtrx, mtrx, g, model)

    ; EM iteration to estimate the background
    bkg_new = bkg * (y_reweight / (Xb + bkg * reweight))

    y_with_backgr =  y - bkg_new
    y_with_backgr_reweight = y_with_backgr * reweight

    ; Compute PRiL solutions and estimate intercepts with function dst_glmnet taking into account
    ; the background estimation given by EM iteration
    self->dst_glmnet, strpril, y_with_backgr_reweight, fit, model, adaptive, weights=weights
    print, '** REGPATH **'
    ; Selection of the optimal solution and intercept in the path of solutions provided by function dst_glmnet
    self->dst_glmnet_regpath_bisect, strpril ,fit, saturated_value, opsf, tol=tol,extend_sat_region, nn=nn
    print, '** END REGPATH **'
    ; The optimal solution provided by the function dst_glmnet_regpath_bisect is saved in strpril.x and the
    ; estimated intercept is saved in strpril.bg
    beta_tmp = transpose(*strpril.x)
    
    if bg_backup gt intercept_backgr then begin
      beta_tmp[where(beta_tmp lt sat_lev)]=0
    endif
    
    bg_tmp = *strpril.bg
    ; Identification of primary saturation pixels
    pr_tmp = s[where(beta_tmp)]

    ; Identification of diffraction fringes pixels from the estimated primary saturation region
    self->identify_fringes_pixels, info, strpril, pr_tmp, g_fringes_new

    ; Image values on identified diffraction fringes pixels g_fringes_new
    y_exp_fringes = im[g_fringes_new]
    ; Product mtrx * beta_tmp rescaled according to the PRiL strPRiLategy
    Xb_tmp = idl_Xb(im, s, beta_tmp, dim_mtrx, mtrx, g, model)
    Xb_tmp = Xb_tmp / reweight
    ; Values of  the product mtrx * beta_tmp on fringes pixels g
    Xb_tmp = Xb_tmp[0:n_g-1]
    ; Background estimation
    bkg_tmp = bkg_new + make_array(n_elements(reweight),value = bg_tmp) / reweight
    ; Background estimate on fringes pixels g
    bkg_tmp = bkg_tmp[0:n_g-1]

    xb_mask_tmp = im * 0.
    xb_mask_tmp[g] = Xb_tmp

    bkg_mask_tmp = im * 0.
    bkg_mask_tmp[g] = bkg_tmp

    ; Predicted values on diffraction fringes pixels g_fringes_new
    y_pred_fringes = xb_mask_tmp[g_fringes_new] + bkg_mask_tmp[g_fringes_new]

    ; Save the sum of predicted values on diffraction fringes g_fringes_new
    flux_pred[n_iter] = total(y_pred_fringes)
    ; Compute c-statistic between y_exp_fringes and y_pred_fringes
    C_stat = c_statistic( y_exp_fringes , y_pred_fringes)
    c_stat_iter[n_iter] = c_stat

    print, ' Iteration number ', n_iter, ': C-stat = ', c_stat_iter[n_iter], ' Flux pred = ', flux_pred[n_iter], ' Flux exp = ', total(y_exp_fringes)


    if c_stat gt 1. then begin
      n_iter = n_iter + 1.
      ; Update background
      bkg = bkg_new + make_array(n_elements(reweight),value = bg_tmp) / reweight
      bg = bg_tmp
      ; Update solution
      beta = beta_tmp
      g_fringes = g_fringes_new
      y_pred_fringes_old = y_pred_fringes
    endif else begin
      stop_reg = 1.
    endelse


  ENDWHILE
  lower_bound_c_stat = 0.6

  if c_stat gt lower_bound_c_stat then begin
    i_opt  = n_iter
    beta_opt = beta_tmp
    bkg_opt = bkg_new + bg_tmp[0]
    g_fringes = g_fringes_new
    y_pred_fringes_opt = y_pred_fringes
  endif else begin
    i_opt = n_iter-1
    beta_opt = beta
    bkg_opt = bkg
    y_pred_fringes_opt = y_pred_fringes_old
    ;; g_fringes are the ones of the previous iteration
  endelse



  ; the optimal solution is the one which corresponds to the first iteration with C-statistic smaller than 1 provided that it is
  ; higher than the lower_bound_c_stat otherwise it is the one which corresponds to the last iteration with C-statistic higher than 1



  print, ' c_stat_opt: ', c_stat_iter[i_opt]

  strpril.x = ptr_new(beta_opt)
  strpril.c_exp = ptr_new(y_pred_fringes_opt)
  strpril.bg = ptr_new(bkg_opt)
  strpril.c_stat = c_stat_iter[i_opt]
  strpril.g = ptr_new(g_fringes)
  strpril.n_iter = i_opt+1. ;
  strpril.sat_flux = strpril.x
  
  if i_opt eq 0 then begin
    strpril.x = ptr_new(rec_it_0)
    it_0 = 1
  endif
  
end





pro desat_pril::dst_image_synthesis_saturation_region, strpril , beta, opsf, x_im, extend_sat_region , x_init_guess, nn = nn
  ;+
  ; NAME:
  ; dst_image_synthesis_saturation_region
  ; PURPOSE:
  ; Project the reconstructed flux beta into the image space inside the saturation region.
  ; EXPLANATION:
  ; 1) It computes the convolution product between the non-zero intensities obtained from the EM+PRiL method
  ;   and the central core of the psf.
  ; 2) The bloomed intensities are evaluated by using a smoothing procedure (dst_inpaint)
  ; CALLING SEQUENCE:
  ; dst_image_synthesis_saturation_region, strpril , beta , opsf, x_im, extend_sat_region , x_init_guess, nn = nn
  ; INPUTS:
  ; strpril  = dst_strpril global structure for the desaturation routine.
  ; beta = retrieved intensities for saturated pixels
  ; opsf = diffusion component of the psf
  ; extend_sat_region = 1 if a larger saturation region is considered 0 otherwise
  ; OPTIONAL:
  ; x_init_guess = initial guess for the inpaint routine dst_inpaint (default x_init_guess is estimated by a nearest neighbor interpolation using the function InitialGuess)
  ; nn = number of iterations for the inpainting routine dst_inpaint (default nn = 50)
  ; OUTPUT:
  ; x_im = projection of beta into image space (synthesis only in the saturation region)
  ; CALLS:
  ;   CONVOLVE, dst_inpaint
  ; CALLED BY:
  ;   dst_glmnet_regpath_bisect
  ; PROCEDURE:
  ;-

  g_image = *strpril.im > 0
  s  = *strpril.s

  ; primary saturation indexes (defined as pixels in which beta has non-zero coefficients)
  pr = s[where(beta gt 0.)]

  ;
  x_s = g_image * 0.0
  x_s[s] = beta

  ; convolution product between the non-zero intensities obtained from the EM+PRiL method
  ; and the central core of the psf.
  S_psf = CONVOLVE(opsf, x_s)


  x_im = g_image>0.
  
  
  ; we put NaN values in the blooming pixels (blooming pixels are indexes in which beta has null coefficients)
  ; this step is necessary to isolate the blooming pixels from the primary saturated ones in order to use
  ; the smoothing procedure dst_inpaint
  x_im[s] = !Values.F_NaN

  x_im[pr] = S_psf[pr]

  strpril.x = ptr_new(beta)
  ; smoothing procedure to evaluate intensities in blooming region
  self->dst_inpaint, x_im, x_im_output, strpril, extend_sat_region, x_init_guess, nn=nn

  x_im = x_im_output


end



pro desat_pril::dst_image_synthesis_inpaint, strpril , psf, extend_sat_region, x_init_guess
  ;+
  ; NAME:
  ; dst_image_synthesis_inpaint
  ; PURPOSE:
  ; Project solution provided by EM+PRiL algorithm into the image space:
  ; compute the diffraction component to subtract from the image, the convolution between
  ; the retrieved intensities, inside the saturation region, and the central core of the
  ; PSF and the intensities for the bloomed pixels.
  ; EXPLANATION:
  ; 1) It computes the convolution product between the intensities obtained from the EM+PRiL method
  ;   and the central core of the psf.
  ; 2) The diffraction fringes generated by the retrieved intensities are computed and
  ;   subtracted from the original image
  ; 3) The gradient of the original image is computed in order to enlarge the blooming region to be filled  
  ; 4) The bloomed intensities are evaluated by using a smoothing procedure (dst_inpaint)
  ; CALLING SEQUENCE:
  ; dst_image_synthesis_inpaint, strpril , psf, extend_sat_region, x_init_guess
  ; INPUTS:
  ; strpril     = dst_strpril global structure for the desaturation routine.
  ; psf     = structure containing all the psf components, diffraction, dispersion and
  ;           the complete one. This structure is returned as output from dst_psf_gen.pro
  ;           routine.
  ; extend_sat_region = 1 if a larger saturation region is considered 0 otherwise
  ; OPTIONAL:
  ; x_init_guess = initial guess for the inpaint routine dst_inpaint (default x_init_guess is
  ;                 estimated by a nearest neighbor interpolation method using the function InitialGuess)
  ; OUTPUT:
  ; strpril.x = de-saturated image
  ; strpril.b = blooming pixels
  ; CALLS:
  ; CALLED BY:
  ;   DESATURATION
  ; CALLS:
  ;   CONVOLVE, dst_inpaint
  ; PROCEDURE:
  ;-

  g_image = *strpril.im > 0
  s  = *strpril.s
  g  = *strpril.g
  z  = *strpril.z

  ; photon flux estimated by EM+PRiL method
  beta = *strpril.x

  ; primary saturated pixels
  pr = s[where(beta gt 0.)]
  ; blooming pixels
  bloom = s[where(beta eq 0.)]

  x_s = g_image * 0.0
  x_s[s] = *strpril.x

  ; diffusion component of psf
  opsf = psf.opsf
  ; diffraction component of psf
  cpsf = psf.cpsf

  S_psf = CONVOLVE(opsf, x_s)
  C_psf = CONVOLVE(cpsf, x_s)
  
  

  x_im = g_image
  
  ; mask of saturation region
  mask_s = x_im*0.
  mask_s[s]=1.
  
  
  ; Compute the gradient of the image
  ; forward finite difference method
  gradient_forward = image_gradient(x_im)
  ; backward finite difference method
  gradient_backward = image_gradient(x_im,/BACKWARD)
  
  threshold_gradient = 5*10^3
  ; Isolate edges in the gradient of the image computed with forward finite difference formula
  edge_forward=where(gradient_forward gt threshold_gradient)
  ; Isolate edges in the gradient of the image computed with backward finite difference formula
  edge_backward=where(gradient_backward gt threshold_gradient)
  
  ; Mask of edges selected in image gradients computed with both forward and bakward finite difference formula
  mask_edge = mask_s*0.
  mask_edge[edge_backward]=1.
  mask_edge[edge_forward]=1.
  
  ; Fill holes along columns in mask_edge and save the binary mask in mask_new
  mask_new = x_im*0.
  for ix = 0,(size(x_im))[2]-1 do begin & $
    iy = where(mask_edge[ix,*]  eq 1.) & $
    if n_elements(iy) gt 1 then begin & $
     iy_min = min(iy) & $
     iy_max = max(iy) & $
     mask_new[ix, iy_min:iy_max] = make_array(iy_max-iy_min+1,value = 1.)  & $
    endif  & $
  endfor
  
  ; Union of mask_s and mask_new
  mask_fill_edge_columns = mask_s
  mask_fill_edge_columns[where(mask_new eq 1.)]=1.
  
  ; Structure to use in morph_close (in order to fill pixels)
  structure=replicate(0,3,3)
  structure[1]=1
  structure[*,1]=1
  structure[7]=1

  mask_union_s_edge=mask_s
  mask_union_s_edge[where(mask_edge eq 1)]=1
  mask_fill_union_s_edge=morph_close(mask_union_s_edge,structure)
  ; Final mask of the extended saturated region
  mask_extended_sat=mask_fill_edge_columns*mask_fill_union_s_edge
  
  
  ; extension of saturated region
  s_large=where(mask_extended_sat eq 1.)
  
  ; we put NaN values in the blooming pixels (blooming pixels are indexes where beta has null coefficients)
  ; and pixels close to saturation region identified by computing the gradient of the image
  ; this step is necessary to isolate the blooming pixels from the primary saturated ones in order to use
  ; the smoothing procedure dst_inpaint
  
  x_im[s_large] = !Values.F_NaN
  x_im[pr] = S_psf[pr]

  ; Diffraction fringes generated by the retrieved intensities are computed and
  ; subtracted from the original image
  x_im[g] = (g_image[g] - C_psf[g]) > 0

  ; smoothing procedure
  self->dst_inpaint, x_im, x_im_output, strpril, extend_sat_region, x_init_guess

  strpril.x = ptr_new(x_im_output)
  strpril.b = ptr_new(bloom)
end


pro desat_pril::dst_adaptive_weights_mask, strpril, w, threshold_weights=threshold_weights
  ;+
  ; NAME:
  ; dst_adaptive_weights
  ; PURPOSE:
  ; Compute weights to insert in the adaptive l_1 penlty of the Lasso-type method PRiL.
  
  ; EXPLANATION:
  ; Weights values rage between 1 and 2 and they are defined according to the shape of the saturation region:
  ; they are equal to 2 in the top and bottom pixels of each connected component of the saturation region and they
  ; decrease as they are closer to the central part of each connected component of the saturation region. 
  ; The threshold 'threshold_weights' defines how much is large the region where weights have to be equal to 1:
  ; weights values smaller than threshold_weights are setted equal to 1.
  ; CALLING SEQUENCE:
  ; dst_image_synthesis_inpaint, strpril , psf, extend_sat_region, x_init_guess
  ; INPUTS:
  ; strpril     = dst_strpril global structure for the desaturation routine.
  ; psf     = structure containing all the psf components, diffraction, dispersion and
  ;           the complete one. This structure is returned as output from dst_psf_gen.pro
  ;           routine.
  ; extend_sat_region = 1 if a larger saturation region is considered 0 otherwise
  ; OPTIONAL:
  ; x_init_guess = initial guess for the inpaint routine dst_inpaint (default x_init_guess is
  ;                 estimated by a nearest neighbor interpolation method using the function InitialGuess)
  ; OUTPUT:
  ; strpril.x = de-saturated image
  ; strpril.b = blooming pixels
  ; CALLS:
  ; CALLED BY:
  ;   DESATURATION
  ; CALLS:
  ;   CONVOLVE, dst_inpaint
  ; PROCEDURE:
  ;-
  
  
  default, threshold_weights, 1.02
  
  
  s = *strpril.s
  im = *strpril.im
  m = im * 0. & m[s] = 1
  
  ;initialization of the weights mask
  w = m*0. 
  
  ; indexes of saturated pixels
  loc = where(m eq 1.)
  ind = array_indices(m, loc)
  x = ind[0,*] ; column indexes
  y = ind[1,*] ; row indexes

  sortx = x(sort(x))
  x_index = sortx(uniq(sortx))

  xx = x(uniq(x))
  ;
  r = x_index * 0.
  y_center = x_index * 0.
  sum_columns = x_index * 0.
  
  for ix = 0,n_elements(x_index)-1 do begin & $
    x_index_mask = x_index[ix]           & $
    ind = where(x eq x_index[ix])          & $
    yi = y(ind)                             & $
    if n_elements(yi) gt 1 then begin & $ 
    ;compute connected components along each column
    diff_comp=ts_diff(yi,1)
    conn_comp_find = where(diff_comp lt -1)
    conn_comp_find_gt = where(diff_comp ge -1)


    if n_elements(conn_comp_find_gt) ne n_elements(yi) then begin ; if there are more than 1 connected component
      ;case: more than one connected component
      conn_comp_find_last = make_array(n_elements(conn_comp_find)+1,/double)*0.
      conn_comp_find_last[0:n_elements(conn_comp_find)-1]=conn_comp_find
      conn_comp_find_last[n_elements(conn_comp_find)]=n_elements(yi)-1

      kk=0

     for k_comp=0, n_elements(conn_comp_find_last)-1 do begin
       yi_comp=yi[kk:conn_comp_find_last[k_comp]]
       r[ix] = (max(yi_comp) - min(yi_comp)) / 2.        & $
       y_center[ix] = r[ix] + min(yi_comp)          & $
       if r[ix] ne 0. then begin
        tmp_weights = ( (findgen((size(m))[2]) - y_center[ix]) / r[ix] )^4. + 1.
       endif else begin & $
        tmp_weights = 2. & $
       endelse & $
        w[x_index_mask,yi_comp] =  tmp_weights[yi_comp]
        kk=conn_comp_find_last[k_comp]+1
     endfor


   endif else begin
    ;case: one connected component
     r[ix] = (max(yi) - min(yi)) / 2.        & $
     y_center[ix] = r[ix] + min(yi)          & $
     if r[ix] ne 0. then begin
      tmp_weights = ( (findgen((size(m))[2]) - y_center[ix]) / r[ix] )^4. + 1. & $ 
     endif else begin & $
      tmp_weights = 2. & $
     endelse & $
     w[x_index_mask,*] =  tmp_weights ;w[x_index_mask,yi] =  tmp_weights[yi]

   endelse & $
endif else begin
  ; case only one isolated pixel is saturated
  w[x_index_mask,yi] = 2.
endelse
endfor

w[where(w lt threshold_weights and w gt 0.)]=1 ;1.02 1.2
w = w * m


end







pro desat_pril::dst_compare_profiles, strpril, ind_sat_columns, columns_sum, columns_sum_pred, loud
  ;+
  ; NAME:
  ; dst_compare_profiles
  ; PURPOSE:
  ; Compute the flux integrated along the image columns in the overall saturation region both
  ; in the original image and in the de-saturated one.
  ; EXPLANATION:
  ; Compute the sum of values along the saturated image columns of the original image and of the
  ; de-saturated one.
  ; CALLING SEQUENCE:
  ; dst_compare_profiles, strpril, ind_sat_columns, columns_sum, columns_sum_pred, loud
  ; INPUTS:
  ; strpril     = dst_strpril global structure for the desaturation routine.
  ; OUTPUT:
  ; ind_sat_columns = column indexes of the saturation region
  ; column_sum      = array of the same size of ind_sat_columns whose components are the integrated fluxes
  ;                   along the image columns of the original image in the saturation area
  ; column_sum_pred = array of the same size of ind_sat_columns whose components are the integrated fluxes
  ;                   along the image columns of the desaturated image in the saturation area
  ; CALLS:
  ; CALLED BY:
  ;   DESATURATION
  ; CALLS:
  ;
  ; PROCEDURE:
  ;-
  im = *strpril.im
  im_rec = *strpril.x
  s = *strpril.s
  ; mask of saturation region
  mask_s = im_rec*0. & mask_s[s] = 1.
  im_rec_s = im_rec*mask_s
  y_s = im*mask_s

  ; 2d wrapping of the saturated indexes
  ij_sat = array_indices(*strpril.im , s)

  ; Column indexes of saturated pixels
  ind_columns = ij_sat[0,*]

  sortx = ind_columns(sort(ind_columns))
  ; Ordered and without repetition column indexes of saturated pixels
  ind_sat_columns = sortx(uniq(sortx))

  columns_sum_pred = total(abs(im_rec_s),2)
  ; Flux in the desaturated image integrated along the image columns in correspondence of the saturation region
  columns_sum_pred = columns_sum_pred[ind_sat_columns]
  columns_sum = total(abs(y_s),2)
  ; Flux in the saturated image integrated along the image columns in correspondence of the saturation region
  columns_sum = columns_sum[ind_sat_columns]

  if loud eq 1 then begin
    items = ['saturated', 'desaturated']

    plot, ind_sat_columns, columns_sum, title='Integrated profiles of the saturated region' , xtitle = 'Column index', ytitle = 'Sum of pixel values in saturated region', xrange = [min(ind_sat_columns)-1, max(ind_sat_columns)+1], yrange = [0, max([max(columns_sum), max(columns_sum_pred)])], /xstyle, /nodata
    oplot, ind_sat_columns, columns_sum, color = 110, thick = 2
    oplot, ind_sat_columns, columns_sum_pred, color = 50, thick = 2
    al_legend, items, /right, linestyle = [0, 0], textcolors=[255,255] , colors=[110, 50], charsize=1.
  endif


end


function desat_pril::desaturation, wav, ts, te, path, path_save=path_save, sat_lev=sat_lev, npix=npix,$
  core_dim=core_dim , dwavelength = dwavelength, wavstrategy = wavstrategy, peaklam = peaklam, $
  use_prep = use_prep, save_fts=save_fts, aec = aec, loud=loud, psplot = psplot, onewindow = onewindow, pril=pril, $
  model=model, max_iter=max_iter, max_level_sat=max_level_sat, nn=nn , tol=tol, adaptive=adaptive, $
  threshold_weights=threshold_weights, intercept_backgr=intercept_backgr
  ;+
  ; NAME:
  ; desat::desaturation
  ; PURPOSE:
  ; Desaturation routine for saturated SDO/AIA images with SE-DESAT method
  ; EXPLANATION:
  ; Recover the pixel intensity inside the primary saturation region by means of
  ; an alternate iterative algorithm EM+PRiL for the saturated images
  ; inside the user defined time interval.
  ; Moreover, the fringes generated by the recovered components are subtracted and
  ; bloomed intensity are estimated by a smoothing procedure.
  ; CALLING SEQUENCE:
  ; result = obj -> desaturation( wav, ts, te, path, sat_lev=sat_lev, lev=lev, it=it, core_dim=core_dim ,$
  ;           save_fts=save_fts, aec = aec, DWAVELENGTH = dwavelength)
  ; INPUTS:
  ; file  = string array containing the file names for the event taken into account
  ; ts    = user defined analysis starting time
  ; te    = user defined analysis end time
  ; wav   = string array containing the wavelength to be process
  ; OUTPUT:
  ; ** Structure RESULTS, 2 tags, length=8, data length=8:
  ;   DATA            POINTER   <PtrHeapVar4635>
  ;   INFO            POINTER   <PtrHeapVar4636>
  ; OPTIONAL:
  ; sat_lev = saturation intensity level (default = 16300)
  ; core_dim  = radius for the PSF core (default = 5)
  ; npix    = setting the resulting image to be npix*npix (default = 499)
  ; peaklam     = set the wavelength value to use for the generation of the PSF if wavstrategy = 1
  ; wavstrategy = wavelength strategy definition
  ;          0: generate the PSF using the nominal wavelength value of the passband
  ;          1: generate the PSF using the wavelength value defined by peaklam
  ;          2: generate the PSF using the wavelength associated to the BRIGHTEST EMISSIVITY
  ;           value computed by flare_peak_wavelength.pro
  ; max_iter = maximum number of iteration for the iterative method EM+PRiL (default = 10)
  ; max_level_sat = number of pixels which determines if a saturation region has to
  ;                 be considered as a large region (default = 2000)
  ; nn = number of iterations in the smoothing algorithm dst_inpaint (default = 100)
  ; tol = tolerance value for stopping the algorithm for the choice of the optimal regularization parameter (default = 1.e-3)
  ; intercept_backgr = threshold which defines if PRiL solution has to be projected
  ; threshold_weights = constant in weights definition if the adaptive strategy is considered (default = 1.02)
  ; KEYWORDS:
  ; DWAVELENGTH - dwavelength is the fractional change in the wavelength over the nominal wavelength
  ;               so for 131, 131.5 dwavelength would be 0.5/131 = 0.00381679
  ; PASSBANDWAV -
  ; USE_PREP - default 1, if set then use aia_prep to register the data and desat cutout outputs
  ; path_save = path to folder where .fts file will be saved
  ; save_fts  = if set save fts file at the end of the run (default = 1)
  ; aec     = if set will desaturate also sat. images with short exp. time (default = 1)
  ; loud    = if 1 intermediate and final results are shown in windows (default = 1)
  ; ONEWINDOW - if set and LOUD is set then plots are written and then overwritten in the same graphic window
  ; pril - if set will desaturate with EM+PRiL method
  ; MODEL - if set will desaturate with EM+PRiL method with the energy constraint along the image columns of the saturation region
  ; CALLS:
  ; CALLED BY: -
  ; CALLS:
  ;   readfts
  ;   indices_analysis
  ;   savefts
  ;   data_restore_2
  ;   aia_psf_gen
  ;   dst_x_y

  ; :Authors: Sabrina Guastavino, Federico Benvenuto and Richard Schwartz

  ;;;DESAT STRUCTURE DEFINITION
  default, save_fts,  1
  default, loud,    1
  default, npix,    499
  default, core_dim,  5
  default, sat_lev,   15000
  default, aec,     1
  default, path_save, './'
  default, psplot,    0
  default, onewindow, 0
  default, wavstrategy, 0
  default, dwavelength, 0.0
  default, peaklam,   float(wav)
  default, pril, 1
  default, model, 1
  default, tol, 1e-3
  default, max_iter, 10
  default, extend_sat_region, 0
  default, max_level_sat, 2000
  default, nn, 50
  default, adaptive, 1
  default, threshold_weights, 1.02
  default, intercept_backgr, 15.
  

  loadct, 5

  results    = replicate({dst_result},size(/n_e, wav))
  info_results = PTR_NEW(/ALLOCATE_HEAP)

  for i_wav = 0, size(/n_e, wav)-1 do begin
    self_gen = obj_new('desat_gen')
    range = anytim( [ts,te] ) + [-180.0, 180]
    file = self_gen->desat_gen::find_file(path, wav[i_wav], range = range) ; self

    strpril = {dst_strpril}

    ; ADDED A NEW STRUCTURE
    fit = {dst_fit}

    self_gen ->desat_gen::readfts, file ; self

    strpril.file = ptr_new(file)
    strpril.ts   = ts
    strpril.te   = te

    if exist(sat_lev)     then strpril.sat_lev    = sat_lev
    if exist(npix)        then strpril.npix     = npix
    self_gen ->desat_gen::indices_analysis, strpril, aec = aec ; search the files for background estimation (for DESAT)
    self_gen ->desat_gen::readfts, file

    ;;;desaturation wavelength strategy definition
    if wavstrategy eq 0 then begin
      peaklam = float(wav[i_wav])
    endif
    if wavstrategy eq 1 and ~exist(peaklam) then begin
      MESSAGE, 'Error: peaklam not defined for strategy ' +strtrim(wavstrategy,1)
    endif
    if wavstrategy eq 2 then begin
      flare_peak_wavelength, float(wav[i_wav]), peaklam = peaklam;, /plotall
    endif
    if wavstrategy ne 0 then begin
      print, "Desaturation performed at lambda = " + string(peaklam) +" Angstrom"
      dwavelength =fltarr(size(/n_e,peaklam))
      for pw = 0 , size(/n_e,peaklam)-1 do dwavelength[pw] = (peaklam[pw] - float(wav))/float(wav)
    endif

    self_gen ->desat_gen::_bld_filenames, *strpril.time_ind, path_save, peaklam = peaklam, pril = pril, model = model

    self_gen ->desat_gen::ctrl_data, strpril.npix ;set all the maps to npix x npix pixels

    if keyword_set(save_fts) then self_gen ->desat_gen::savefts, /original, use_prep = use_prep, pril = pril

    self_gen->desat_gen::get_data_and_info, strpril, data, info

    psf_ptr = self_gen ->desat_gen::psf( info, dwavelength, core_dim )

    ;initialization of background
    bg = data * 0.0

    n_rec = size(/n_e,*strpril.sat_ind)

    for i=0, n_rec-1 do begin


      strpril.im = ptr_new(data[*, *, i])
      strpril.bg = ptr_new(bg)

      self.filenames = ptr_new(*self_gen.filenames)
      self.psf = ptr_new(*self_gen.psf)

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;PLOT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      text = info[i].INSTRUME+' '+strtrim(info[i].WAVELNTH,1)+' '+anytim(info[i].DATE_OBS, /yoh)
      if loud eq 1 then begin
        numwin = onewindow ? 31 : i
        title= 'AIA Desaturation Routine '
        if ~psplot then window, numwin, xsize = 900, ysize = 600, title= title + text else $
          sps, /colo, /landscape
        !p.multi=[0,3,2]
        !p.charsize = 1.5
        ; plot original image
        index2map, info[i], *strpril.im^0.3, map
        plot_map, map, /positive, /square ,title = 'Original', thick=1.5


      endif

      ;;;; SE-DESAT method
      ; IDENTIFICATION OF SATURATION REGION AND FRINGES PIXELS
      ; check if data is saturated
      check_sat = 1
      self->identify_saturation_regions_pril, info[i], strpril, loud, extend_sat_region, max_level_sat=max_level_sat, check_sat

      if check_sat eq 1. then begin
        print, 'Desaturation ' + string(info[i].wavelnth) + ':' + string(i+1) + ' of ' + $
          string(n_rec), ' Time:', anytim(/atim,info[i].date_obs)



        ; CONSTRUCTION OF MATRIX
        self->dst_sparse_mtrx, strpril, (*self.psf).cpsf, (*self.psf).opsf, model

        ; EM+PRiL ALTERNATE ITERATIVE ALGORITHM
        print,'*****  BEGIN PRiL+EM  *****'
        it_0 = 0
        self->dst_pril_EM_glmnet, strpril, *self.psf, model, extend_sat_region, tol=tol, nn=nn, max_iter=max_iter, info[i], loud, adaptive, it_0, intercept_backgr = intercept_backgr, sat_lev = sat_lev, threshold_weights = threshold_weights
        print,'*****  END PRiL+EM   *****'

        ; SYNTHESIS
        if it_0 ne 1 then begin
        self->dst_image_synthesis_inpaint, strpril, *self.psf, extend_sat_region
        endif
        
        ; COMPARISON OF FLUXES INTEGRATED ALONG THE IMAGE COLUMNS IN CORRESPONDENCE OF THE SATURATION REGION
        self->dst_compare_profiles, strpril, indexes, columns_sum, columns_sum_pred, loud

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;PLOT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        if loud eq 1 and size((*self.psf).cpsf,/n_d) eq 2 then begin

          ; plot the de-saturated image
          index2map, info[i] ,(*strpril.x>0)^0.3, map
          plot_map, map, /positive, /square ,title = 'Reconstruction', thick=1.5

          ; zoom of the reconstruction
          plot_map, map, /positive, /square ,  CENTER = [info[i].xcen,info[i].ycen], FOV=[2.,2.], title = 'Reconstruction (zoom)', thick=1.5
          !p.charsize = 1


          !p.multi = 0
          !p.thick = 1

        endif
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



        data_fill = (self_gen->get(/data))
        data_fill[*,*,(*strpril.sat_ind)[i]] = *strpril.x

        index2map, (self_gen->get(/index)), data_fill, map

        self_gen -> set, index=(self_gen->get(/index)), map=map
        self_gen -> set, grid=30, /limb

        if keyword_set(save_fts) then begin
          self_gen ->desat_gen::savefts, reform( info[i].date_obs ), info_str = strpril, original = 0, pril = pril
        endif

      endif else begin

        print, '*** ' + text + ' is not saturated! ***'

        data_fill = (self_gen->get(/data))


        index2map, (self_gen->get(/index)), data_fill, map

        self_gen -> set, index=(self_gen->get(/index)), map=map
        self_gen -> set, grid=30, /limb
      endelse

    endfor

    results[i_wav].data = ptr_new((self_gen->get(/data))[*,*,*strpril.time_ind])
    results[i_wav].info = ptr_new((self_gen->get(/index))[*strpril.time_ind])

  endfor
  if psplot then begin & device, /close & x & endif

  return, results

end



pro desat_pril__define, void

  void={desat_pril, $
    filenames: ptr_new(), $
    psf: ptr_new(), $
    inherits sdo}
  return

end



